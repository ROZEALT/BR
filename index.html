<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Battle Royale</title>
    <style>
        body { margin: 0; background: black; overflow: hidden; }
    </style>
    <script src="https://threejs.org/build/three.js"></script>
</head>
<body>
    <script>
        // Constants
        const PLAYER_RADIUS = 5;
        const PLAYER_HEIGHT = 10;
        const PLAYER_SPEED = 2;
        const PLAYER_HEALTH = 100;

        const BULLET_SPEED = 5;
        const BULLET_RADIUS = 1;

        const INITIAL_ZONE_RADIUS = 150;
        const ZONE_SHRINK_SPEED = 0.05;

        const ITEM_RADIUS = 2;
        const WEAPON_DAMAGE = 20;

        const NUM_AI = 5;
        const AI_SPEED = 1;

        const GROUND_SIZE = 400;

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 50, 0);
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Player class
        class Player {
            constructor(x, z) {
                this.position = new THREE.Vector3(x, PLAYER_HEIGHT / 2, z);
                this.health = PLAYER_HEALTH;
                this.hasWeapon = false;
                this.mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 32),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            move(dx, dz) {
                this.position.x += dx;
                this.position.z += dz;
                this.position.x = Math.max(-GROUND_SIZE / 2 + PLAYER_RADIUS, Math.min(GROUND_SIZE / 2 - PLAYER_RADIUS, this.position.x));
                this.position.z = Math.max(-GROUND_SIZE / 2 + PLAYER_RADIUS, Math.min(GROUND_SIZE / 2 - PLAYER_RADIUS, this.position.z));
                this.mesh.position.copy(this.position);
            }

            shoot(bullets, direction) {
                if (this.hasWeapon) {
                    bullets.push(new Bullet(this.position.clone(), direction));
                }
            }
        }

        // AI class
        class AI {
            constructor(x, z) {
                this.position = new THREE.Vector3(x, PLAYER_HEIGHT / 2, z);
                this.health = PLAYER_HEALTH;
                this.hasWeapon = Math.random() < 0.5;
                this.mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 32),
                    new THREE.MeshBasicMaterial({ color: 0x0000ff })
                );
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            moveTowards(target) {
                const dx = target.x - this.position.x;
                const dz = target.z - this.position.z;
                const dist = Math.hypot(dx, dz);
                if (dist > 0) {
                    this.position.x += (dx / dist) * AI_SPEED;
                    this.position.z += (dz / dist) * AI_SPEED;
                    this.mesh.position.copy(this.position);
                }
            }
        }

        // Bullet class
        class Bullet {
            constructor(position, direction) {
                this.position = position.clone();
                this.direction = direction.clone().normalize().multiplyScalar(BULLET_SPEED);
                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(BULLET_RADIUS, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            update() {
                this.position.add(this.direction);
                this.mesh.position.copy(this.position);
            }
        }

        // Item class
        class Item {
            constructor(x, z, type) {
                this.position = new THREE.Vector3(x, ITEM_RADIUS, z);
                this.type = type;
                this.mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(ITEM_RADIUS, 16, 16),
                    new THREE.MeshBasicMaterial({ color: type === 'weapon' ? 0xff0000 : 0x00ff00 })
                );
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }
        }

        // Zone class (visualized as a cylinder for simplicity)
        class Zone {
            constructor(radius) {
                this.center = new THREE.Vector3(0, 0, 0);
                this.radius = radius;
                this.mesh = new THREE.Mesh(
                    new THREE.CylinderGeometry(radius, radius, 1, 64, 1, true),
                    new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide, transparent: true, opacity: 0.3 })
                );
                this.mesh.position.y = 0.5;
                this.mesh.rotation.x = Math.PI / 2;
                scene.add(this.mesh);
            }

            shrink() {
                this.radius -= ZONE_SHRINK_SPEED;
                if (this.radius < 5) this.radius = 5;
                this.mesh.scale.set(this.radius / INITIAL_ZONE_RADIUS, 1, this.radius / INITIAL_ZONE_RADIUS);
            }

            isInside(position) {
                return Math.hypot(position.x - this.center.x, position.z - this.center.z) <= this.radius;
            }
        }

        function checkCollision(pos1, r1, pos2, r2) {
            return pos1.distanceTo(pos2) < r1 + r2;
        }

        // Initialize
        const player = new Player(0, 0);
        let ais = [];
        for (let i = 0; i < NUM_AI; i++) {
            const x = Math.random() * GROUND_SIZE - GROUND_SIZE / 2;
            const z = Math.random() * GROUND_SIZE - GROUND_SIZE / 2;
            ais.push(new AI(x, z));
        }
        let items = [];
        for (let i = 0; i < 10; i++) {
            const x = Math.random() * GROUND_SIZE - GROUND_SIZE / 2;
            const z = Math.random() * GROUND_SIZE - GROUND_SIZE / 2;
            const type = Math.random() < 0.5 ? 'weapon' : 'health';
            items.push(new Item(x, z, type));
        }
        let bullets = [];
        const zone = new Zone(INITIAL_ZONE_RADIUS);

        camera.position.set(0, 100, 0);
        camera.lookAt(0, 0, 0);

        let keys = {};
        window.addEventListener('keydown', (e) => { keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key] = false; });

        let mouseDown = false;
        let mouseX = 0, mouseY = 0;
        window.addEventListener('mousedown', (e) => { mouseDown = true; });
        window.addEventListener('mouseup', (e) => { mouseDown = false; });
        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        let gameOver = false;
        let win = false;

        // Health display (2D overlay)
        const healthDiv = document.createElement('div');
        healthDiv.style.position = 'absolute';
        healthDiv.style.top = '10px';
        healthDiv.style.left = '10px';
        healthDiv.style.color = 'white';
        healthDiv.style.fontSize = '24px';
        document.body.appendChild(healthDiv);

        function animate() {
            requestAnimationFrame(animate);

            if (gameOver) return;

            // Player movement
            let dx = 0, dz = 0;
            if (keys['w'] || keys['W']) dz -= PLAYER_SPEED;
            if (keys['s'] || keys['S']) dz += PLAYER_SPEED;
            if (keys['a'] || keys['A']) dx -= PLAYER_SPEED;
            if (keys['d'] || keys['D']) dx += PLAYER_SPEED;
            if (dx !== 0 || dz !== 0) {
                const len = Math.hypot(dx, dz);
                dx /= len;
                dz /= len;
                player.move(dx * PLAYER_SPEED, dz * PLAYER_SPEED);
            }

            // Shooting
            if (mouseDown) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(mouseX, mouseY), camera);
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const direction = new THREE.Vector3(point.x - player.position.x, 0, point.z - player.position.z);
                    player.shoot(bullets, direction);
                }
                mouseDown = false; // Prevent continuous shooting
            }

            // AI logic
            ais = ais.filter(ai => ai.health > 0);
            ais.forEach(ai => {
                ai.moveTowards(player.position);
                if (ai.hasWeapon && Math.random() < 0.005) {
                    const direction = new THREE.Vector3(player.position.x - ai.position.x, 0, player.position.z - ai.position.z);
                    bullets.push(new Bullet(ai.position.clone(), direction));
                }
            });

            // Update bullets
            bullets = bullets.filter(bullet => {
                bullet.update();
                if (Math.abs(bullet.position.x) > GROUND_SIZE / 2 || Math.abs(bullet.position.z) > GROUND_SIZE / 2) {
                    scene.remove(bullet.mesh);
                    return false;
                }

                // Hit player
                if (checkCollision(bullet.position, BULLET_RADIUS, player.position, PLAYER_RADIUS)) {
                    player.health -= WEAPON_DAMAGE;
                    scene.remove(bullet.mesh);
                    if (player.health <= 0) gameOver = true;
                    return false;
                }

                // Hit AI
                for (let i = 0; i < ais.length; i++) {
                    if (checkCollision(bullet.position, BULLET_RADIUS, ais[i].position, PLAYER_RADIUS)) {
                        ais[i].health -= WEAPON_DAMAGE;
                        if (ais[i].health <= 0) {
                            scene.remove(ais[i].mesh);
                            ais.splice(i, 1);
                        }
                        scene.remove(bullet.mesh);
                        return false;
                    }
                }
                return true;
            });

            // Pickup items
            items = items.filter(item => {
                if (checkCollision(player.position, PLAYER_RADIUS, item.position, ITEM_RADIUS)) {
                    if (item.type === 'weapon') player.hasWeapon = true;
                    else if (item.type === 'health') player.health = Math.min(PLAYER_HEALTH, player.health + 50);
                    scene.remove(item.mesh);
                    return false;
                }
                return true;
            });

            // Zone
            zone.shrink();
            if (!zone.isInside(player.position)) {
                player.health -= 0.5;
                if (player.health <= 0) gameOver = true;
            }
            ais.forEach(ai => {
                if (!zone.isInside(ai.position)) ai.health -= 0.5;
            });
            ais = ais.filter(ai => {
                if (ai.health <= 0) {
                    scene.remove(ai.mesh);
                    return false;
                }
                return true;
            });

            // Win condition
            if (ais.length === 0) {
                win = true;
                gameOver = true;
            }

            // Update health display
            healthDiv.textContent = `Health: ${Math.floor(player.health)}`;

            // Game over display
            if (gameOver) {
                const message = win ? 'You Win!' : 'Game Over';
                const overDiv = document.createElement('div');
                overDiv.style.position = 'absolute';
                overDiv.style.top = '50%';
                overDiv.style.left = '50%';
                overDiv.style.transform = 'translate(-50%, -50%)';
                overDiv.style.color = win ? 'green' : 'red';
                overDiv.style.fontSize = '48px';
                overDiv.textContent = message;
                document.body.appendChild(overDiv);
            }

            // Camera follow player (top-down)
            camera.position.x = player.position.x;
            camera.position.z = player.position.z - 50;
            camera.position.y = 50;
            camera.lookAt(player.position.x, 0, player.position.z);

            renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
